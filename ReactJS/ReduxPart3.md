# Handling Asynchronous Actions in Redux  

Redux's simplicity works well for synchronous actions. The user causes an event, an action is created, the action is dispatched to the reducer, the reducer updates the state, and the containers are re-rendered. When you have an asynchronous action, such as an Ajax call, or any function with a callback, dispatching actions is harder. In order to make this work, you will need a Redux middleware called [redux-thunk](https://github.com/gaearon/redux-thunk). (This is not the only way to handle this. There are other libraries such as [redux-saga](https://redux-saga.js.org/) to assist with async actions.)

redux-thunk is based on a simple concept: instead of just dispatching actions -- simple JavaScript objects with a type and payload -- you can dispatch functions that take `dispatch` as an argument. These functions are expected to later dispatch either actions or other functions. That may be obtuse without seeing it in action, so let's get started.

## Setting Up Redux-Thunk  

Redux-thunk is a middleware, so you'll have to activate it when you call Redux's `createStore`. Assuming your application was created with create-react-app, this will be in your `src/index.js`. A simple example:

```jsx
// index.js
import {createStore, applyMiddleware} from 'redux';
import reduxThunk from 'redux-thunk';
import reducer from './reducer';

const store = createStore(
    reducer,
    applyMiddleware(reduxThunk)
);
```

## Creating an Asynchronous Action  

Imagine you have an application that needs to *geocode* an address. (Geocoding is turning an address or location into latitude/longitude coordinates.) Google provides an API to do this, but it will require making a request to that API.

To do this, create an action creator as normal for storing the latitude and longitude:

```jsx
// actions.js
export const SET_LAT_LON = 'SET_LAT_LON';

const setLatLon = (payload) => {
  return {
    type: SET_LAT_LON,
    payload: payload
  }
}
```

We will call this action creator after the Ajax request returns. To make the Ajax request, we write another action creator that returns a function:

```jsx
// actions.js
const encode = encodeURIComponent;

export const geocodeAddress = (address) => {
  return (dispatch, getState) => {
    fetch(`http://maps.googleapis.com/maps/api/geocode/json?address=${encode(address)}`)
      .then(response => {
        return response.json();
      })
      .then(json => {
        const loc = json.results[0].geometry.location;
        dispatch(setLatLon({
          lat: loc.lat,
          lon: loc.lng
        }));
      })
  }
}
```

The returned function takes two arguments, `dispatch` and `getState`. We aren't using `getState` in this example, but it's included so you are aware of it. In this function, we use fetch to make the request and then on success, call `dispatch` with an action generated by our `setLatLon` action creator.

Beyond this change, we do not have to change how we use Redux. Our reducers and containers do not have to work any differently to handle asynchronous actions.

## References  

* [A demo of Redux thunk in action](https://github.com/tiycnd/redux-async-demo)

---

# Handling Authentication in Redux  

We have covered asynchronous actions in Redux, and authentication is a specialized version of that. Every API with authentication is different, but most provide a way to get an `authentication token` -- a unique key to identify yourself to the backend.

To demonstrate authentication with Redux, we are going to use an API built for this lesson.

* [API Documentation](https://github.com/twhitacre/simple-rails-auth/blob/master/README.md)

* [Demo Application](https://github.com/tiycnd/redux-auth-demo)

## Storing a token  

The API we are using has an endpoint at `/login` that takes a username and password and returns an object in JSON with the key `auth_token`. Using redux-thunk, we can build a set of actions and a reducer to handle this:

```jsx
// actions.js
import request from "superagent";

export const SET_TOKEN = 'SET_TOKEN';
export const SET_ERROR = 'SET_ERROR';

const makeActionCreator = function(actionType) {
    return function(payload) {
        return {type: actionType, payload: payload}
    }
}

const setToken = makeActionCreator(SET_TOKEN);
const setError = makeActionCreator(SET_ERROR);

const baseURL = "https://user-auth-test.herokuapp.com";
const api = (path) => baseURL + path;

export const login = (email, password) => {
    return (dispatch) => {
        request
            .post(api("/login"))
            .send({email: email, password: password})
            .end((err, res) => {
                if (err) {
                    return dispatch(setError(res.body.errors));
                } else {
                    dispatch(setError(null));
                }

                dispatch(setToken(res.body['auth_token']));
            })
    }
}
```

```jsx
// reducer.js
import {SET_TOKEN, SET_ERROR} from './actions';

import update from 'immutability-helper';

const initialState = {
    token: null,
    error: null
}

const reducer = (state = initialState, action) => {
    switch (action.type) {
        case SET_ERROR:  
            return update(state, {
                error: {
                    $set: action.payload
                }
            })
        case SET_TOKEN:
            return update(state, {
                token: {
                    $set: action.payload
                }
            });
        default:
            return state;
    }
}

export default reducer;
```

This is standard redux-thunk code. In the case of our particular API, there is a `/dashboard` endpoint to get user info given a token. We will want to expand our login action to handle that:

```jsx
// actions.js
export const login = (email, password) => {
    return (dispatch, getState) => {
        request
            .post(api("/login"))
            .send({email: email, password: password})
            .end((err, res) => {
                if (err) {
                    return dispatch(setError(res.body.errors));
                } else {
                    dispatch(setError(null));
                }

                dispatch(setToken(res.body['auth_token']));
                dispatch(getDashboard(res.body['auth_token']));
            })
    }
}

const getDashboard = (token) => {
    return (dispatch, getState) => {
        request
            .get(api("/dashboard"))
            .set('X-AUTH-TOKEN', getState()['token'])
            .end((err, res) => {
                if (err) {
                    return dispatch(setError(res.body.errors));
                }
                dispatch(setUser({email: res.body.email, 'full_name': res.body.full_name, message: res.body.message}))
            })
    }
}
```

We can see that `login` makes an HTTP request, and when it gets a response, dispatches two actions, `setToken` and `getDashboard`. `getDashboard` is another thunk, so it runs and makes a new request, dispatching setUser.

## Persisting a login  

The problem with the above code is that it requires the user to log in on every page load. That is suboptimal! If we save our auth token in a cookie, we can load it when we load the page and maintain our logged in status.

To make working with cookies easier, we will install a small library:

```shell
npm install --save js-cookie
```

We will need to set the cookie in our `login` action:

```jsx
// actions.js
import Cookies from 'js-cookie';

export const login = (email, password) => {
    return (dispatch) => {
        request
            .post(api("/login"))
            .send({email: email, password: password})
            .end((err, res) => {
                dispatch(setToken(res.body['auth_token']));
                dispatch(getDashboard());
                Cookies.set('token', res.body['auth_token'], {expires: 7});
            })
    }
}
```

The only other thing we will need to do is to restore the token on page load. This will require us to dispatch an action when our application is going to mount, so we go to our `App` component, connect it to Redux, and have it dispatch using `componentWillMount`.

```jsx
// App.js
import React, {Component} from 'react';
import {connect} from 'react-redux';

import {loadTokenFromCookie} from "./actions";

class App extends Component {
    componentWillMount() {
        const loadToken = this.props.loadToken;  
        loadToken();
    }
}

const mapStateToProps = (state) => {
    return {};
}

const mapDispatchToProps = (dispatch) => {
    return {
        loadToken: () => dispatch(loadTokenFromCookie())
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(App);
```

When our app starts, our new `loadTokenFromCookie` action is dispatched. Let's see it:

```jsx
// actions.js
import Cookies from 'js-cookie';

export const loadTokenFromCookie = () => {
    return (dispatch) => {
        const token = Cookies.get('token');
        if (token) {
            dispatch(setToken(token));
            dispatch(getDashboard());
        }
    }
}
```

## Conclusion  

* Using redux-thunk, we can authenticate with an API using Ajax calls.

* Persisting our authorization token is a good idea, and we can do with with a cookie.

## Resources  

* [Sample redux authentication app](https://github.com/tiycnd/redux-auth-demo)

* [Documentation on sample API we used](https://gist.github.com/twhitacre/4f52489f989e3ce04ebaaf6fd33b4897)
